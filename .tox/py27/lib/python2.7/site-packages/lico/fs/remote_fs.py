# Copyright 2019-present Lenovo
# Confidential and Proprietary

import fcntl
import hashlib
import logging
import shutil
import threading
import time
from contextlib import contextmanager
from functools import wraps
from os import makedirs
from os.path import basename, exists, isdir, normcase, normpath, sep
from tempfile import NamedTemporaryFile, SpooledTemporaryFile

import requests
from six import PY2, text_type
from webdav3.client import Client, Urn, WebDavXmlUtils, wrap_connection_error
from webdav3.exceptions import (
    NotEnoughSpace, RemoteResourceNotFound, ResponseErrorCode,
)

from .base import FileSystemBaseBackend
from .exceptions import RemoteFileSystemException

logger = logging.getLogger(__name__)


def _convert_py2_str(s):
    if PY2 and isinstance(s, text_type):
        return s.encode('utf-8')
    else:
        return s


class WebdavClient(Client):
    def __init__(self, options, auth=None, headers=None, timeout=30):
        super(WebdavClient, self).__init__(options)
        self.timeout = timeout
        self.headers = headers
        self.auth = auth

    def get_headers(self, action, headers_ext=None):
        headers = super(WebdavClient, self).get_headers(action, headers_ext)
        if self.headers is not None:
            headers = dict(
                headers,
                **self.headers
            )

        return headers

    def execute_request(self, action, path, data=None, headers_ext=None):
        response = requests.request(
            method=Client.requests[action],
            url=self.get_url(path),
            auth=self.auth,
            headers=self.get_headers(action, headers_ext),
            timeout=self.timeout,
            data=data,
            stream=True,
        )
        if response.status_code == 507:
            raise NotEnoughSpace()
        if response.status_code >= 400:
            raise ResponseErrorCode(
                url=self.get_url(path),
                code=response.status_code,
                message=response.content
            )
        return response

    @wrap_connection_error
    def download_from_without_check(self, buff, remote_path):
        """Downloads file from WebDAV and writes it in buffer.

        :param buff: buffer object for writing of downloaded file content.
        :param remote_path: path to file on WebDAV server.
        """
        urn = Urn(remote_path)
        response = self.execute_request(action='download', path=urn.quote())
        shutil.copyfileobj(response.raw, buff)

    @wrap_connection_error
    def info_without_check(self, remote_path):
        """Gets information about resource on WebDAV.
        More information you can find by link
        http://webdav.org/specs/rfc4918.html#METHOD_PROPFIND

        :param remote_path: the path to remote resource.
        :return: a dictionary of information attributes
        and them values with following keys:
                 `created`: date of resource creation,
                 `name`: name of resource,
                 `size`: size of resource,
                 `modified`: date of resource modification.
        """
        urn = Urn(remote_path)
        response = self.execute_request(action='info', path=urn.quote())
        path = self.get_full_path(urn)
        return WebDavXmlUtils.parse_info_response(
            content=response.content,
            path=path,
            hostname=self.webdav.hostname
        )

    @wrap_connection_error
    def list_info(self, remote_path=Client.root):
        directory_urn = Urn(remote_path, directory=True)
        if directory_urn.path() != Client.root:
            if not self.check(directory_urn.path()):
                raise RemoteResourceNotFound(directory_urn.path())

        response = self.execute_request(
            action='list', path=directory_urn.quote()
        )
        urns = WebDavXmlUtils.parse_get_list_response(response.content)

        path = Urn.normalize_path(self.get_full_path(directory_urn))
        return [
            {'filename': urn.filename(), 'is_dir': urn.is_dir()}
            for urn in urns if Urn.compare_path(path, urn.path()) is False
        ]


class RemoteFileSystem(FileSystemBaseBackend):

    def __init__(self, options, target, auth=None, timeout=300):
        headers_ext = {
            'Host': target,
            'Accept-Encoding': ''
        }
        self.client = WebdavClient(
            options, auth=auth,
            headers=headers_ext, timeout=timeout
        )
        self.auth = auth
        self.timeout = timeout
        self._options = options
        self._target = target

    def _samefile(self, src, dst):
        return normcase(
            normpath(_convert_py2_str(src))
        ) == normcase(
            normpath(_convert_py2_str(dst))
        )

    def _destinsrc(self, src, dst):
        src = normpath(_convert_py2_str(src))
        dst = normpath(_convert_py2_str(dst))
        if not src.endswith(sep):
            src += sep
        if not dst.endswith(sep):
            dst += sep
        return dst.startswith(src)

    def walk(self, top, topdown=True, onerror=None, followlinks=False):
        # Remote files do NOT use any links
        # therefore, followlinks will be ignored
        try:
            names = self.client.list_info(top)
        except Exception as err:
            if onerror is not None:
                onerror(err)
            return

        dirs, nondirs = [], []
        for name in names:
            if name['is_dir']:
                dirs.append(name['filename'])
            else:
                nondirs.append(name['filename'])

        if topdown:
            yield top, dirs, nondirs
        for name in dirs:
            new_path = self.path_join(top, name)
            for x in self.walk(new_path, topdown, onerror, followlinks):
                yield x

        if not topdown:
            yield top, dirs, nondirs

    def mkdir(self, path, mode=0o777):
        self.client.mkdir(_convert_py2_str(path))

    def makedirs(self, path, mode=0o777):
        path = _convert_py2_str(path)
        head, tail = self.path_split(path)
        if not tail:
            head, tail = self.path_split(head)
        if head and tail and not self.client.check(head):
            self.makedirs(head)
            if tail == self.curdir:  # xxx/newdir/. exists if xxx/newdir exists
                return

        if self.client.check(path) and self.client.is_dir(path):
            return
        self.client.mkdir(path)

    def listdir(self, path):
        return self.client.list(_convert_py2_str(path))

    def mknod(self, filename, mode=0o600, device=0):
        filename = _convert_py2_str(filename)
        if self.client.check(filename):
            raise RemoteFileSystemException(
                'File exists: {0}'.format(filename)
            )
        self.client.upload_to(None, filename)

    def remove(self, path):
        path = _convert_py2_str(path)
        if self.client.check(path) and self.client.is_dir(path):
            raise RemoteFileSystemException(
                'Is a directory: {0}'.format(path)
            )
        self.client.clean(path)

    def rename(self, old, new):
        self.client.move(_convert_py2_str(old), _convert_py2_str(new))

    def chdir(self, path):
        pass

    def chown(self, path, uid, gid):
        pass

    def chmod(self, path, mode):
        pass

    def path_isreadable(self, path, uid, gid):
        path = _convert_py2_str(path)
        if self.client.check(path):
            return True
        else:
            raise RemoteFileSystemException(
                "No such file or directory: {0}".format(path))

    def lchown(self, path, uid, gid):
        pass

    def symlink(self, src, dst):
        src = _convert_py2_str(src)
        dst = _convert_py2_str(dst)
        if self.path_isdir(src):
            self.copytree(src, dst)
        else:
            self.copyfile(src, dst)

    def path_getsize(self, filename):
        size = self.client.info(_convert_py2_str(filename))['size']
        return int(size) if size else 0

    def path_getsize_without_check(self, filename):
        size = self.client.info_without_check(
            _convert_py2_str(filename)
        )['size']
        return int(size) if size else 0

    def path_exists(self, path):
        path = _convert_py2_str(path)
        if not path:
            return False
        return self.client.check(path)

    def path_isdir(self, path):
        path = _convert_py2_str(path)
        if not path:
            return False
        try:
            return self.client.is_dir(path)
        except RemoteResourceNotFound:
            return False

    def path_isfile(self, path):
        path = _convert_py2_str(path)
        if not path:
            return False
        try:
            return not self.client.is_dir(path)
        except RemoteResourceNotFound:
            return False

    def path_abspath(self, path):
        path = _convert_py2_str(path)
        return path

    def path_getmtime(self, filename):
        timestr = self.client.info(_convert_py2_str(filename))['modified']
        timeformat = '%a, %d %b %Y %H:%M:%S %Z'
        timestruct = time.strptime(timestr, timeformat)
        return time.mktime(timestruct)

    def rmtree(self, path):
        path = _convert_py2_str(path)
        if self.client.check(path):
            self.client.clean(path)

    def copytree(self, src, dst):
        src = _convert_py2_str(src)
        dst = _convert_py2_str(dst)
        if self._samefile(src, dst):
            raise RemoteFileSystemException(
                'src: {0} and dst: {1} are the same for copytree.'
                .format(src, dst)
            )
        if not self.client.check(src):
            raise RemoteFileSystemException(
                'src: {0} not exists for copytree'.format(src)
            )
        if not self.client.is_dir(src):
            raise RemoteFileSystemException(
                'src {0} is not a directory for copytree'.format(src)
            )
        if self.client.check(dst):
            raise RemoteFileSystemException(
                'dst {0} already exists for copytree'.format(dst)
            )
        self.client.copy(src, dst)

    def copy(self, src, dst):
        src = _convert_py2_str(src)
        dst = _convert_py2_str(dst)
        if self.client.check(dst) and self.client.is_dir(dst):
            dst = self.path_join(dst, basename(src))
        self.copyfile(src, dst)

    def move(self, src, dst):
        src = _convert_py2_str(src)
        dst = _convert_py2_str(dst)
        if self.client.check(dst) and self.client.is_dir(dst):
            if self._samefile(src, dst):
                return
            dst = self.path_join(dst, basename(src))
            if self.client.check(dst):
                raise RemoteFileSystemException(
                    'dst {0} already exists for move'.format(dst)
                )
        if not self.client.check(src):
            raise RemoteFileSystemException(
                'src {0} not exists for move'.format(src)
            )
        if self.client.is_dir(src) and self._destinsrc(src, dst):
            raise RemoteFileSystemException(
                'src {0} cannot move into '
                'its sub directory dst {1} for move'
                .format(src, dst)
            )
        self.client.move(src, dst, overwrite=True)

    def copyfile(self, src, dst):
        src = _convert_py2_str(src)
        dst = _convert_py2_str(dst)
        if self._samefile(src, dst):
            raise RemoteFileSystemException(
                'src: {0} and dst: {1} are the same '
                'for copyfile.'
                .format(src, dst)
            )
        if not self.client.check(src):
            raise RemoteFileSystemException(
                'src {0} not exists for copyfile'.format(src)
            )
        if self.client.is_dir(src):
            raise RemoteFileSystemException(
                'src {0} cannot be a directory '
                'for copyfile'.format(src)
            )
        if self.client.check(dst) and self.client.is_dir(dst):
            raise RemoteFileSystemException(
                'dst {0} cannot be a directory '
                'for copyfile'.format(dst)
            )
        self.client.copy(src, dst)

    def download_directory(self, src, dst):
        src = _convert_py2_str(src)
        dst = _convert_py2_str(dst)
        if not self.path_exists(src):
            raise RemoteFileSystemException(
                'src {0} not exists for '
                'download_directory'.format(src)
            )
        if not self.path_isdir(src):
            raise RemoteFileSystemException(
                'dst {0} should be a directory '
                'for download_directory'.format(src)
            )
        if not exists(dst):
            self.client.download_directory(src, dst)
            return
        for sub in self.listdir(src):
            sub_path = self.path_join(src, sub)
            if not self.path_isdir(sub_path):
                self.client.download_file(sub_path, self.path_join(dst, sub))
            else:
                target_path = self.path_join(dst, sub)
                self.download_directory(sub_path, target_path)

    def download_file(self, src, dst):
        src = _convert_py2_str(src)
        dst = _convert_py2_str(dst)
        if not self.path_exists(src):
            raise RemoteFileSystemException(
                'src {0} not exists for download_file'.format(src)
            )
        if self.path_isdir(src):
            raise RemoteFileSystemException(
                'dst {0} should not be a '
                'directory for download_file'.format(src)
            )
        if exists(dst) and isdir(dst):
            dst = self.path_join(dst, basename(src))
        self.client.download_file(src, dst)

    def count_file_lines(self, filename):
        with SpooledTemporaryFile() as f:
            self.client.download_from(f, _convert_py2_str(filename))
            f.seek(0, 0)
            return self._get_linenum(f)

    def read_content(self, filename, start=0, num=None):
        with SpooledTemporaryFile() as f:
            self.client.download_from(f, _convert_py2_str(filename))
            f.seek(0, 0)
            return self._read_fp(f, start, num)

    def read_content_without_check(self, filename, start=0, num=None):
        with SpooledTemporaryFile() as f:
            self.client.download_from_without_check(
                f, _convert_py2_str(filename)
            )
            f.seek(0, 0)
            return self._read_fp(f, start, num)[0]

    def open_file(self, filename, mode='r'):
        filename = _convert_py2_str(filename)
        hash_file = self._hash_file(filename)
        # check the file lock_ex
        if exists(hash_file):
            with open(hash_file):
                pass
        return RemoteFile(filename, mode, self)

    def _hash_file(self, filename):
        filename = _convert_py2_str(filename)
        _file = normcase(normpath(filename))
        hl = hashlib.md5()
        hl.update(_file.encode('utf-8'))
        lock_folder = '/var/run/lico/fs/lock'
        if not exists(lock_folder):
            makedirs(lock_folder)
        return self.path_join(lock_folder, hl.hexdigest())

    @contextmanager
    def write_with_lock_file(self, filename, mode='r'):
        filename = _convert_py2_str(filename)
        hash_file = self._hash_file(filename)
        with open(hash_file, 'w') as lock_file:
            fcntl.flock(lock_file, fcntl.LOCK_EX)
            fp = RemoteFile(filename, mode, self)
            try:
                yield fp
            finally:
                fp.close()
                fcntl.flock(lock_file, fcntl.LOCK_UN)

    def size(self, path):
        headers = {
            'Host': self._target
        }
        payload = {
            'filepath': path
        }
        url = '{0}/api/file/usage/'.format(
            self._options['webdav_hostname']
        )
        res = requests.get(
            url=url, headers=headers, params=payload,
            auth=self.auth, timeout=self.timeout
        )
        res.raise_for_status()
        return res.json()


def catch(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except ValueError:
            logger.info('Data receive thread exit')
            return
        except Exception as e:
            raise e
    return wrapper


class RemoteFile(object):
    def __init__(self, name, mode, fs):
        self._fs = fs
        self._recv_buff = NamedTemporaryFile()
        self._mode = mode
        self._fp = open(self._recv_buff.name, self._mode)
        self._remote_filename = name
        self._prev_offset = 0

        # Check mode and do some prepare
        self._check_mode()

        self._prev_timestamp = self._fs.path_getmtime(self._remote_filename)

        self._init_buff()
        threading.Thread(
            target=self._get_content,
            args=(
                self._fs,
                self._recv_buff,
                self._remote_filename,
                self._prev_offset,
                self._prev_timestamp
            )
        ).start()

    def __enter__(self):
        return self

    def __exit__(self, *excinfo):
        self._exit()

    @property
    def file_handle(self):
        return self._fp

    def _check_mode(self):
        if self._mode.startswith('r'):
            if not self._fs.path_exists(self._remote_filename):
                raise RemoteFileSystemException(
                    'Remote file {0} does not exist'.format(
                        self._remote_filename
                    )
                )
        elif self._mode.startswith('w'):
            if self._fs.path_exists(self._remote_filename):
                self._fs.remove(self._remote_filename)
            self._fs.mknod(self._remote_filename)
        elif self._mode.startswith('a'):
            if not self._fs.path_exists(self._remote_filename):
                self._fs.mknod(self._remote_filename)

    def _init_buff(self):
        self._fs.client.download_from(self._recv_buff, self._remote_filename)
        self._prev_offset = self._recv_buff.tell()
        self._recv_buff.flush()

    @catch
    def _get_content(
            self,
            fs,
            recv_buff,
            filename,
            prev_offset,
            prev_timestamp
    ):
        with SpooledTemporaryFile() as temp_buff:
            while True:
                if recv_buff.closed:
                    break
                time.sleep(1)
                # Check file whether exist
                # for others may remove the file during the thread
                if not fs.path_exists(filename):
                    break
                cur_timestamp = fs.path_getmtime(filename)
                if cur_timestamp <= prev_timestamp:
                    continue
                prev_timestamp = cur_timestamp
                temp_buff.seek(0, 0)
                temp_buff.truncate()
                # Check file whether exist
                # for others may remove the file during the thread
                if not fs.path_exists(filename):
                    break
                fs.client.download_from(temp_buff, filename)
                cur_offset = temp_buff.tell()
                if cur_offset < prev_offset:
                    temp_buff.seek(0, 0)
                    prev_offset = 0
                else:
                    temp_buff.seek(prev_offset)
                    prev_offset = cur_offset
                recv_buff.write(temp_buff.read())
                recv_buff.flush()

    def _exit(self):
        try:
            if self._fp.closed:
                return
            if self._mode.startswith('r') and '+' not in self._mode:
                return
            self._fp.seek(0, 2)
            if 0 == self._fp.tell():
                self._fs.client.upload_to('', self._remote_filename)
            else:
                self._fp.flush()
                with open(self._recv_buff.name) as f:
                    self._fs.client.upload_to(f, self._remote_filename)
        finally:
            self._fp.close()
            self._recv_buff.close()

    def close(self):
        self._exit()
